\documentclass[a4paper, 11pt]{report}
\usepackage[utf8]{inputenc}
%\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{url}
\usepackage{alltt}
\usepackage{multicol}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{proof}
\usepackage{amssymb}
\usepackage{algpseudocode}

\usepackage{bussproofs}

\newcommand{\seq}{\vdash} % the sequent sign
\newcommand{\impl}{\supset} %logical connectives: implies, not, and, or
\renewcommand{\lnot}{\neg}
\renewcommand{\land}{\wedge}
\renewcommand{\lor}{\vee}

%Commands for constructing proof trees with bussproofs. See the chapter on the LK system for examples.
\newcommand{\UnaryInfCm}[1]{\UnaryInfC{$#1$}}
\newcommand{\BinaryInfCm}[1]{\BinaryInfC{$#1$}}
\newcommand{\RightLabelm}[1]{\RightLabel{$#1$}}
\newcommand{\AxiomCm}[1]{\AxiomC{$#1$}}

%Normal text in math mode ("math text")
\newcommand{\mt}[1]{\textnormal{#1}}

% Using a report without chapters
\renewcommand*\thesection{\arabic{section}}

\newcommand{\nub}{\texttt{nub}}
\newcommand{\elim}{\texttt{elim}}
\newcommand{\DeltaG}{$\Delta_G$}
\newcommand{\DeltaGk}{$\Delta_G^k$}
\newcommand{\colvec}[1]{\left(\begin{array}{c}#1\end{array}\right)}

%Theorem environments
\newtheorem{theorem}{Theorem}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}

%\lstset{
%  basicstyle=\footnotesize\ttfamily,
%  breaklines=true,
%  frame=lines
%}

\title{Cut Introduction\\ \vspace{0.5cm} Cut-Formulas with Multiple Universal Quantifiers}

\author{Janos Tapolczai}

\begin{document}
\maketitle

\abstract{
In \cite[Ch. 5]{cutIntro2013}, algorithmic cut-introduction is described, albeit restricted to cut-formulas with
one universal quantifier. This document extends the mechanism described therein to cut-formulas with an
arbitrary number of universal quantifiers.\\

Specifically, we replace the $\Delta$ operator with $\Delta_G$. Both descend through a list of terms in parallel in search for a common teram structure, but whereas $\Delta$ is limited to introducing only one variable, $\Delta_G$ can introduce an arbitrary number. Also, a specific definition of completeness will be given, namely that, for every set of terms and an unbounded number of variables, every decomposition has a uniqe normal form, which $\Delta_G$ computes. Later on, we also give an operator $\Delta_G^k$ for a bounded number of variables, and the corresponding completeness result that every decomposition computed by $\Delta_G^k$ is in {\em weak k-normal form}.
}

\tableofcontents
\newpage

\section{Definition}

We first generalize the definition of a decomposition to the multiple-variable case:

\begin{definition}
Let $T = \{t_1,\ldots,t_n\}$ be a set of ground terms. A decomposition $D$ of $T$ is a pair, written as
$U \circ_{\bar{\alpha}} W$, where $U$ is a set of terms containing the variables $\alpha_1,\ldots,\alpha_m$,
and $W = \left\{\bar{w}_1 = \colvec{w_{1,1}\\ \vdots\\w_{1,m}},\ldots,\bar{w}_q = \colvec{w_{q,1}\\ \vdots\\ w_{q,m} } \right\}$
is a set of vectors of ground terms s.t.
$T = U \circ_{\bar{\alpha}} W = \{ u[\bar{\alpha} \backslash \bar{w}]\ |\ u \in U, \bar{w} \in W\}$.
The size of a decomposition $U \circ_{\bar{\alpha}} W$ is $|U| + |W|$.
When it is clear that the variables in question are $\alpha_1,\ldots,\alpha_m$, we just write $U \circ W$.
\end{definition}

The semantics are as follows: every $u \in U$ represents the common part of some subset $T'$ of $T$, with variables $\alpha_1,\dots,\alpha_m$ in
the leaves of its tree structure; every column vector in $W$
has values for the variables $\alpha_1,\dots,\alpha_m$, such that $u[\bar{\alpha} \backslash \bar{w}] \in T'$.
The one-variable decompositions in \cite[Ch. 5]{cutIntro2013} are the result of restricting $m$ to be 1.

\section{Generalized $\Delta$-Vector}

The produce decompositions in accordance with the above definition, one need only change the definition of the $\Delta$-vector and extend it to deal with vectors of variables instead of a single one.\\

\noindent
First, we define the helper-function \texttt{nub}\footnote{\texttt{nub} is the common name for the duplicate elimination function in functional languages.} which eliminates duplicates:

\begin{algorithm}
\caption{\nub}
\label{alg.DeltaG}
\begin{algorithmic}
\Function{\nub}{$(u, (\bar{w}_1,\dots,\bar{w}_q)$}
  \State let $\alpha_{F+1}$ be the $\alpha$-variable with the lowest index which occurs in $u$.
  \While{there exist $i,j$ with $i < j$ s.t. $[\forall 1 \leq k \leq q]\ w_{k,i} = w_{k,j}$}
    \For{$[\forall 1 \leq k \leq q]$}\State delete $w_{k,j}$ from $\bar{w}_k$ \EndFor
    \State replace $\alpha_{j+F}$ with $\alpha_{i+F}$ in $u$
    \For{$[\forall j \leq k \leq m]$}\State replace $\alpha_{k+F}$ with $\alpha_{k+F-1}$ in $u$ \EndFor
  \EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}

\noindent
We then define the generalized delta-vector $\Delta_G$ via this recursive\footnote{the distribution of $\alpha$-indexes does imply a global state, but this is only a technicality.} function:

\begin{algorithm}
\caption{Generalized $\Delta$-vector \DeltaG}
\label{alg.DeltaG}
\begin{algorithmic}
\Function{\DeltaG}{$t_1,\ldots,t_n$: a list of terms}
  \State \Return transposeW(\DeltaG'($t_1,\ldots,t_n$))
\EndFunction
\Function{\DeltaG'}{$t_1,\ldots,t_n$: a list of terms}
  \If{$t_1 = t_2 = \ldots = t_n \land n > 0$}
    \Comment case 1: all terms identical
    \State \Return $(t_1,())$
  \ElsIf{$t_i = f(t_1^i,\ldots,t_m^i)$ for $1\leq i\leq n$}
    \Comment case 2: recurse
    \State $(\bar{w}_1,\dots,\bar{w}_q) \gets \bigsqcup\limits_{1 \leq j \leq m} \pi_2(\Delta_G(t_j^1,\ldots,t_j^n))$
    \Comment $\bigsqcup \equiv$ concatenation
    \State $u_j \gets \pi_1(\Delta_G(t_j^1,\ldots,t_j^n))$ for all $j \in \{1,\ldots,m \}$
    \State \Return nub($f(u_1,\ldots,u_m), (\bar{w}_1,\ldots,\bar{w}_q)$)
  \Else
    \Comment case 3: introduce new $\alpha$
    \State \Return $(\alpha_\mt{FRESH}, (t_1,\ldots,t_n))$
  \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\noindent
where $\sqcup$ is list concatenation, $\pi$ is the tuple projection function and $\alpha_{\mt{FRESH}}$ denotes an instance of $\alpha$ with a globally unique index that starts with 1 and is incremented by 1 with each instantiation left-to-right.\\
\\
Observe that, due to the incremental assignment of indices to generate $\alpha$-instances, $f(u_1,\dots,u_m)$ always contains a contiguous set $\{\alpha_k,\dots,\alpha_{k+q}\}$ (for a priori unknown $k$ and $q$).\\

Strictly speaking, neither applying \texttt{nub} nor case 1 of $\Delta_G$ would be necessary, but they minimize the number of $\alpha$-instances: \texttt{nub} merges two $\alpha$-instances {\em if their respective values in all $w$-vectors are identical}, whereas case 1 eliminates an $\alpha$-instance {\em if its values are the same in every $w$-vector}.

\subsection{Behavior}

$\Delta_G$ is a generalization of $\Delta$ in a certain sense, although not a strict one. Both try to find the maximal common structure in $t_1,\dots,t_n$, but the ability to use an unbounded number of $\alpha$-instances instead of just one means that $\Delta_G$ will recursively descend until it encounters a termset in which at least two terms have different heads, whereas $\Delta$ will introduce its $\alpha$ as soon as it is called on two different termsets where not all heads are equal, even if the heads {\em within} each termset are.

\subsection{Soundness}

W.l.o.g. we assume that the set of variables which occur in $u$ is $\{\alpha_1,\dots,\alpha_m\}$.

\begin{theorem}
\textbf{Soundness of $\Delta_G$.}
Let $t_1,\dots,t_n$ be terms. If $\Delta_G(t_1,\dots,t_n) = (u,(\bar{w}_1,\dots,\bar{w}_q))$, then $t_i = u[\bar{\alpha}\backslash\bar{w}_i]$ (for $1\leq i \leq n)$.
\label{thm:DeltaGSoundness}
\end{theorem}

\begin{proof} We proceed by induction on the depth $u$.
\paragraph{Base case.} $u$'s depth is 0.\\
If not all $t_1,\dots,t_n$ are equal, $\Delta_G(t_1,\dots,t_n) = \left(\alpha_1,(t_1,\dots,t_n)\right)$ per definition.
$t_i = u[\bar{\alpha}\backslash \bar{w}_i] = \alpha_1[\alpha_1\backslash w_{i,1}] = t_i$.\\
If all terms are equal, then $\Delta_G(t_1,\dots,t_n) = (t_1,())$. We simply get $t_i = t_1$.


\paragraph{Step case.} Assume the soundness for a depth of $\leq d$. We show the soundess for depth $d+1$.\\

\noindent
If all terms are equal, $\Delta_G(t_1,\dots,t_n) = (t_1,())$, which is obviously correct.
If not all terms are equal, $\Delta_G(t_1,\dots,t_n) = (f(u_1,\dots,u_m), (\bar{w}_1,\dots,\bar{w}_q))$.\\

\noindent
For the second case, let $\Delta_G(t_j^1,\dots,t_j^n) = (u_j,(\bar{w}_{\alpha_1}\dots,\bar{w}_{\alpha_k}))$. Per the IH, the soundness condition holds for $\Delta_G(t_j^1,\dots,t_j^n)\ (1\leq j\leq m)$ --- i.e. $t_j^i = u_j[\bar{\alpha}\backslash \bar{w}_i]$. Per the uniqueness constraint on instances of $\alpha$, $u_{j_1}$ and $u_{j_2}$ will contain non-intersecting sets of $\alpha$ iff $j_1 \neq j_2$. If we therefore take $f(u_1,\dots,u_m)$ and the concatenation of all $\pi_2(\Delta_G(t_j^1,\dots,t_j^n))$, the soundness condition will still hold.\\

It may, however, be the case that for two different $\alpha_{j_1}$ and $\alpha_{j_2}$ ($j_1 < j_2$), $\bar{w}_{i,j_1} = \bar{w}_{i,j_2}$ ($\forall 1 \leq i \leq q$). In this case, \nub\ replaces $\alpha_{j_2}$ with $\alpha_{j_1}$ in $u_1,\dots,u_m$ and deletes $w_{i,j_2}$, effectively merging $\alpha_{j_1}$ and $\alpha_{j_2}$. For all $j_3 > j_2$, $\alpha_{j_3}$ is renamed to $\alpha_{j_3 - 1}$, preserving the 1-to-1 correspondence between $\alpha_j$ and $w_{i,j}$ for all $i$ and $j$. Since only the superfluous $\alpha_{j_2}$ was eliminated, the substituiton $u[\bar{\alpha}\backslash \bar{w}_i]$ (for any $i$) yields the same result as before and the soundness condition is still fulfilled.\\
\end{proof}



\subsection{Completeness}

To define the sense in which $\Delta_G$ is complete, we must first introduce the notion of a normal form for decompositions. For a single $\alpha$, this was done in \cite[Sect. 4]{Hetzl2012}, where a calculus for decompositions into $u,S$ was presented. The full calculus, as well as the theoretical results of that paper will not be replicated for the case of multiple $\alpha$ here, but we will make use of a few analogous notions.

\subsubsection{A calculus of decompositions for multiple $\alpha$}

\iffalse
\begin{definition}
  \textbf{Decomposition and substitution.}
  A term $u$ and a list of vectors $S$ are a decomposition and $u \circ S$ is a substitution for a set of terms $\{t_1,\dots,t_n\}$ if
  $$
    \{t_1,\dots,t_n\} =
    u \circ S =
    \{ u[\bar{\alpha} \backslash s_{i,i}, \dots, s_{q,i} |\ 1 \leq i \leq n]  \}
    %\{u[\bar{\alpha}\backslash(s_{1,1},\dots,s_{q,1}),\dots,\bar{\alpha}\backslash(s_{1,n},\dots,s_{q,n})]\}
  $$
  where $\bar{\alpha} = (\alpha_1,\dots,\alpha_q)$, $u[\bar{\alpha}\backslash(s_{1,j},\dots,s_{q,j})] = u[\alpha_1\backslash s_{1,j},\dots,\alpha_q\backslash s_{q,j}]$, s.t.
  \begin{enumerate}
    \item $S$ does not contain any $\alpha_i$ and
    \item the variables occurring in $u$ are numbered $\alpha_1,\dots,\alpha_q$ left-to-right.
  \end{enumerate}
\end{definition}
\fi

\begin{definition}[Left-shifting]
  A decomposition may be left-shifted if, for some $\alpha_j$, all terms in $(w_{1,j},\dots,w_{q,j})$ start with a
  common function symbol $f$ of arity $r$, i.e. $(w_{1,j},\dots,w_{q,j}) = (f(a_{1,1},\dots,a_{1,r}),\dots,f(a_{n,1},\dots,a_{n,r}))$.
  Then, left-shifting for $\alpha_j$ is defined as:
%
  $$
  \infer[\leftarrow]{
    \left\{ u[\alpha_j\backslash f(\alpha_j^1,\dots,\alpha_j^r)] \circ W\left[w_{1,j}\backslash \colvec{a_{1,1}\\\ldots\\a_{n,1}},\ldots,w_{q,j}\backslash\colvec{a_{1,r}\\\ldots\\a_{n,r}}\right]\ |\ u \in U \right\}
  }
   { U \circ W }  
  $$
%
  \noindent
  where $\alpha_j^1,\dots,\alpha_j^r$ are fresh variable names.

  \begin{example}\label{ex.leftShiftEx}
    Let $\{t_1,\dots,t_n\} = \{f(g(a,b),x),f(g(c,d),y)\}$ and let\\
    $u = \{f(\alpha_1,\alpha_3)\},\ W=(\bar{w}_1,\bar{w}_2)$ with $\bar{w}_1 = \colvec{g(a,b)\\g(c,d)},\ \bar{w}_2 = \colvec{x\\y}$.\\
    We can left-shift for $\alpha_1$:
%
    $$
    \infer[\leftarrow]{ \{f(g(\alpha_1,\alpha_2),\alpha_3)\} \circ \left(\colvec{a\\c},\colvec{b\\d},\colvec{x\\y}\right) }
     { \{f(\alpha_1,\alpha_3)\} \circ \left(\colvec{g(a,b)\\g(c,d)},\colvec{x\\y}\right) }  
    $$
%
  \end{example}
\end{definition}

\begin{definition}[Merging and splitting $\alpha$]
  Suppose that there exist $\alpha_{j_1}$ and $\alpha_{j_2}$ in $U$ ($i \neq j$) s.t. $w_{i,j_1} = w_{i,j_2}$.
  Then we can replace $\alpha_{j_2}$ with $\alpha_{j_1}$, replace $\alpha_k$ with $\alpha_{k-1}\ (k > max\{j_1,j_2\})$ in $U$
  and delete $w_{i,j_2}$ from all $\bar{w}_i \in W$. Conversely, we can rename multiple occurrences of
  $\alpha_j$ to $\alpha_{j_1},\ldots,\alpha_{j_n}$ and duplicate $w_{i,j}$ in $\bar{w}_i$ $n$ times.
  These operations are called merging \& splitting and obviously preserve the result of $\circ_{\bar{\alpha}}$.
\end{definition}

\begin{definition}[$\alpha$-elimination]
  Suppose that, for a decomposition $U \circ_{\bar{\alpha}} W$, there exists an $\alpha_j$ in $u$ s.t.
  its values are the same in every $w$-vector, i.e. $w_{1,j} = w_{2,j} = \dots = w_{q,j}$.
  Then we can eliminate $\alpha_i$ by replacing $U$ with $\{u[\alpha_i\backslash w_{1,j}]\ |\ u \in U\}$ and deleting $w_{i,j}$
  from every $\bar{w}_i$ in $W$ without changing the result of $\circ_{\bar{\alpha}}$.
\end{definition}

\begin{definition} A decomposition $U \circ_{\bar{\alpha}} W$ is in normal form iff no left-shift,
no merging and no $\alpha$-elimination are possible.
\end{definition}

\begin{theorem}Every decomposition has a unique normal form (up to $\alpha$-renaming). \label{thm:uniqueNormalForm}\end{theorem}

\begin{proof}
  We first show the statement for decompositions of the form $\{u\} \circ W$, i.e. for those with only one term in $U$.
  \begin{enumerate}
    \item Observe that the order in which merging operations and $\alpha$-eliminations are applied is irrelevant. 
    \item The order in which two left-shift operations are applied is irrelevant. Suppose $\alpha_{j_1}$ and $\alpha_{j_2}$ occur in $u$ and
          we can left-shift for both. Left-shifting for $\alpha_{j_1}$ only replaces $\alpha_{j_1}$ in $u$ with a term containing fresh
          $\alpha_{j_1}^1,\dots,\alpha_{j_1}^r$ and the elements $w_{i,j_1}$ in $W$ with new elements $w_{i,j_1}^1,\dots,w_{i,j_1}^r$.
          The applicability of a left-shift for $\alpha_{j_2}$ remains unaffected.
    \item Left-shifting and $\alpha$-elimination commute.
          Suppose both left-shifting and $\alpha$-elimination can be performed on $\alpha_j$, i.e.\\
          $(w_{1,j},\dots,w_{q,j}) = (f(a_{j,1},\dots,a_{j,r}),\dots,f(a_{j,1},\dots,a_{j,r}))$.
          $\alpha$-elimination replaces $\alpha_j$ with $f(a_{j,1},\dots,a_{j,r})$ in $u$ and deletes $w_{i,j}$ from $\bar{w}_i$ in $W$.
          Left-shifting replaces $\alpha_j$ with $f(\alpha_j^1,\dots,\alpha_j^r)$ in $u$ and $w_{i,j}$ with $\colvec{a_{j,1}\\\dots\\a_{j,r}}$
          for all $i$. $\alpha$-elimination can then be performed on $\alpha_j^1,\dots,\alpha_j^r$, giving the same result.
    \item Left-shifting and merging commute. Suppose that $\alpha_{j_1}$ and $\alpha_{j_2}$ occur in $u$ s.t. $\alpha_{j_1}$ and $\alpha_{j_2}$
          can be merged and left-shifting is possible on both.
          Since merging is possible, $w_{i,j_1} =w_{i,j_2}$ for all $i$. Merging $\alpha_{j_1}$ and $\alpha_{j_2}$ replaces $u$
          with $u[\alpha_{j_2}\backslash \alpha_{j_1}]$ and deletes $w_{i,j_2}$ from every $\bar{w}_i$ in $W$.
          If we left-shift on $\alpha_{j_1}$ and $\alpha_{j_2}$, we introduce $\alpha_{j_1}^1,\dots,\alpha_{j_1}^r$ and $\alpha_{j_2}^1,\dots,\alpha_{j_2}^r$
          with corresponding elements $w_{i,j_1}^1,\dots,w_{i,j_1}^r$ and $w_{i,j_2}^1,\dots,w_{i,j_2}^r$
          such that $w_{i,j_1}^k = w_{i,j_2}^k\ (1 \leq i \leq q, 1 \leq k \leq r)$.
          Merging $(\alpha_{j_1}^1, \alpha_{j_2}^1), \dots, (\alpha_{j_1}^r, \alpha_{j_2}^r)$ then delivers the same result as merging $(\alpha_{j_1},\alpha_{j_2})$ did. 
  \end{enumerate}

  Given this proof and the fact that left-shifting, merging and $\alpha$-elimination have to be applied ``in parallel'' (to every $u \in U$), we can easily see that a decomposition $U \circ W$ is in normal form iff, $\forall u \in U$, $\{u\} \circ W$ is in normal form.
\end{proof}

\begin{corollary}
If $t_1 = \dots = t_n$ and $n > 0$, the normal form of a decomposition for $(t_1,\dots,t_n)$ is $t_1,()$.
\label{cor:allTermsEq}
\end{corollary}

\begin{proof}
Take the trivial decomposition $\alpha_1,(t_1,\dots,t_n)$ and perform $\alpha$-elimination.
\end{proof}

%\begin{corollary}
%If $u,S$ is a decomposition in which all possible left-shifts, but no merges and $\alpha$-eliminations, have been performed, its normal form $u',S'$ is the result of performing %every possible merge and $\alpha$-elimination.
%\label{cor:leftShiftsFirst}
%\end{corollary}

%\begin{proof}
%Follows from the fact that the order in which left-shifts, merges and $\alpha$-elimination are performed is irrelevant.
%\end{proof}

\medskip

%-----------------------------------------------------------------------------
% Completeness proof begins here
%-----------------------------------------------------------------------------

\subsubsection{Completeness proof}

\begin{lemma}
\textbf{\texttt{nub} performs all merges.}
W.l.o.g. let $U \circ W$ be a decomposition. Then $\texttt{nub}(U,W) = (U',W')$ such that $U' \circ W'$ equals $U \circ W$ modulo merging and that no merge is possible in $U' \circ W'$.
\label{thm:nubAllMerges}
\end{lemma}

\begin{theorem}
  \textbf{Completeness of $\Delta_G$.}
  If $\{u\} \circ W$ is a decomposition for a non-empty set of terms $\{t_1,\dots,t_n\}$, then $\Delta_G(t_1,\dots,t_n) = (u',W')$ s.t. $\{u'\} \circ W'$ is the normal form of $u \circ W$.
  \label{thm:DeltaGCompleteness}
\end{theorem}


\begin{proof}
  W.l.o.g. we assume a contiguous numbering of the $\alpha$ occurring in $u$.
  We proceed by induction on the depth of $t_1,\dots,t_n$.

  \paragraph{Base case.} Let all $t_i\ (1 \leq i \leq n)$ have a depth of 0. We have two sub-cases:
  \begin{enumerate}
    \item All terms are equal. This is the condition of the first case of $\Delta_G$, which, per Corollary~\ref{cor:allTermsEq}, is the normal form of $\{u\} \circ W$.
    \item Not all terms are equal. The terms can only be constants. In either case, the only possible decomposition is $u=\alpha, W=(t_1,\dots,t_n)$. This is exactly the third case of $\Delta_G$.
  \end{enumerate}

  \paragraph{Step case.} Assume that $\Delta_G$ is complete if all $t_i\ (1 \leq i \leq n)$ have a depth $\leq d$.
  We again have two cases:
  \begin{enumerate}
    \item All terms are equal. As in the base case, $\Delta_G$ computes the normal form of $\{u\} \circ W$, per Corollary~\ref{cor:allTermsEq}.
    \item Not all terms are equal. If not all terms begin with a common function symbol with arity $m$, the only possible decomposition is $u=\alpha, W=(t_1,\dots,t_n)$. This is again exactly the third-case of $\Delta_G$.
    If all terms do begin with a common function symbol of arity $m$, then $t_i = f(t_1^i,\dots,t_m^i)$ for  $(1 \leq i \leq n)$. This is the condition for the second case of $\Delta_G$. $u$ can take one of two forms:
    \begin{enumerate}
      \item $u=\alpha$. Since a left-shift is possible due to the common function symbol $f$, such a decomposition is not in normal form. If we left-shift, case 2.(b) applies.
      \item $u=f(u_1,\dots,u_m)$. In this case, $u_i, W_i\ (1 \leq i \leq m)$ must be a decomposition for the terms $t_i^1,\dots,t_i^n$. For these decomposition, completeness of $\Delta_G$ holds per the IH. Now let $\widehat{u}=f(\widehat{u_1},\dots,\widehat{u_m}),\widehat{W}=\bigsqcup\limits_{1 \leq i \leq m} W_i$ be the decomposition\footnote{Technically, we also have to transpose $\widehat{W}$ to fulfill the definition of a decomposition. This is done in the final step of $\Delta_G$.} created by simply concatenating all $u_i,W_i$, where $\widehat{u_i}$ is $u_i$, with its variables renamed to avoid clashes between any two $u_{i_1}, u_{i_2}$. Per definition of $\Delta_G$, $(\widehat{u},\widehat{W})$ is precisely the result of the second case of $\Delta_G$ (without the application of \texttt{nub}). Furthermore, per Theorem~\ref{thm:uniqueNormalForm}, $\{u\} \circ W$ and $\{\widehat{u}\} \circ \widehat{W}$ have the same normal form.\\

      Due to the IH, $\{\widehat{u}\} \circ \widehat{W}$ can only differ from $\{u'\} \circ W'$ through merging. Per Lemma~\ref{thm:nubAllMerges}, the application of \texttt{nub} to $\{\widehat{u}\} \circ \widehat{W}$ performs all possible merges, which results in the unique normal form of both $\{\widehat{u}\} \circ \widehat{W}$ and $\{u\} \circ W$.
    \end{enumerate}
  \end{enumerate}
\end{proof}

\begin{corollary}
  Every non-empty set of terms $\{t_1,\dots,t_n\}$ has a decomposition of the form $\{u\} \circ W$. Decompositions of that form have exactly one normal form (up to $\alpha$-renaming) and $\Delta_G$ computes it.
  \label{thm:deltaGCorrectness}
\end{corollary}

\begin{proof}
  Follows from Theorems~\ref{thm:DeltaGSoundness}, \ref{thm:uniqueNormalForm} \& \ref{thm:DeltaGCompleteness} and from $\Delta_G$ being a total function.
\end{proof}


\section{$\Delta$-Table}

$\Delta_G$ only computes so-called {\em simple decompositions}, i.e. decompositions of the form $\{u\} \circ W$. To put such simple decompositions together into complex ones, we employ the $\Delta$-table, defined thus:

\begin{definition}
  \label{def:deltaTableDef}
  Let $T$ be a term set. The $\Delta$-table for $T$ is a list of key/value-entries, where each
  entry is of the form $W_\Delta \Rightarrow (U_\Delta = \{ (u_1,T_1),\ldots,(u_n,T_n) \})$,
  where $W_\Delta$ is a list of ground term vectors, $u_i$ is a term containing variables,
  and $T_i$ is a subset of $T$ s.t. the following two conditions are satisfied:

  \begin{enumerate}
    \item For every entry $W_\Delta \Rightarrow \{ (u_1,T_1),\ldots,(u_n,T_n) \}$, $\{u_i\} \circ W_\Delta$ is a
          decomposition of $T_i$ in normal form (for $1 \leq i \leq n$).
    \item For every $T' \subseteq T$, there is a pair $W_\Delta \Rightarrow U_\Delta$ in the $\Delta$-table s.t.
          $(u,T') \in U_\Delta$.
  \end{enumerate}
\end{definition}

This definition mirrors the description in \cite{cutIntro2013}, with the exception of the type of the keys: there, $W$ was just a list of terms; here, it is a list of column vectors.
We build up the $\Delta$-table as follows: for every $T' \subseteq T$, we compute
$\Delta_G(T') = (u, W)$ and insert $(u,T')$ with the key $W$ (if an entry
$W \Rightarrow U_\Delta$ already exists, we replace it with $W \Rightarrow U_\Delta \cup \{(u,T')\}$).
We then iterate over the $\Delta$-table and, for each entry $W \Rightarrow U_\Delta$,
try to find a subset $\{(u_{i_1},T_{i_1}),\ldots,(u_{i_n},T_{i_n})\}$ of $U_\Delta$ s.t.
$\{u_{i_1},\ldots,u_{i_n}\} \circ W$ is a decomposition of $T$. This is called {\em folding} the $\Delta$-table. Formally, it proceeds thus:

\begin{algorithm}
\caption{Folding the $\Delta$-table}
\label{alg.folding}
\begin{algorithmic}
\Function{fold}{\texttt{dt}: $\Delta$-table, $T$: termset to decompose}
  \For{$W_\Delta \Rightarrow \{(u_1,T_1),\dots,(u_n,T_n)\}$}
    \For{every $U \subseteq \{u_1,\dots,u_n\}$ and $U' \in \texttt{renamings}(U)$}
        \If{$U' \circ W_\Delta$ is a decomposition of $T$}
          \State \textbf{yield} $U' \circ W_\Delta$
        \EndIf
    \EndFor
  \EndFor
\EndFunction
\State
\Function{renamings}{$U$: set of terms with variables}
    \For{every $\{u_1,\dots,u_m\} \subseteq U$ and every set of injections
        \State $\{f_1: V(u_1) \mapsto V(U),\dots, f_m: V(u_m) \mapsto V(U)\}$}
          \State \textbf{yield} $\bigcup\limits_{1 \leq i \leq m} u_i[V(u_i)\backslash \texttt{map}(f_i,V(u_i))]$
    \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

\noindent
$V(U)$ is the set of variables occuring in a set of terms $U$, \texttt{map}$(f,U)$ applies the function $f$ to every element of a set/list $U$ and \textbf{yield} is the same as \textbf{return}, with the difference that it allows a function to continue. Let us now show the soundness and completeness of this {\em folding} algorithm.

\subsection{Soundness}

\begin{theorem}[Soundness]
\label{theo.decompositionSoundness}
Let $T$ be a term set. If $U \circ W$ is extracted from folding the $\Delta$-table, then $U \circ W$ is a decomposition of $T$ in normal form.
\end{theorem}

\begin{proof}
By the above definition of folding, we only return $\{u_{i_1},\ldots,u_{i_n}\} \circ W$ which actually are decompositions. The fact that these objects
are in normal form follows immediately from point 1 of Definition~\ref{def:deltaTableDef} and from the proof of Theorem~\ref{thm:uniqueNormalForm}.
\end{proof}

\subsection{Completeness}

\begin{theorem}[Completeness]
\label{theo.decompositionCompleteness}
Let $T$ be a term set and let $U = \{u_1,\dots,u_m\} \circ W$ be a decomposition of $T$ in normal form.
$U \circ W$ is returned by folding the $\Delta$-table.
\end{theorem}

\begin{proof}
From Theorem~\ref{thm:uniqueNormalForm}, it follows that, $\forall u \in U$, $\{u\} \circ W$ is in normal form. Moreover, to every $u \in U$, we can associate
a subset $T'$ of $T$ which $\{u\} \circ W$ compresses, that is: $\{u\} \circ W = T'$. By Definition~\ref{def:deltaTableDef}, the $\Delta$-table will therefore contain an
entry $W \Rightarrow \{\dots, (u'_1,T_1),\dots,(u'_m,T_m) ,\dots\}$ s.t. $u_i$ and $u'_i$ are equivalent up to $\alpha$-renaming.\\

Now let us denote by $\{f_1,\dots,f_m\}$ a set of renamings s.t. applying $f_i$ to the variables of $u'_i$ results in $u_i$. Since $u'_i$ and $u_i$ are equivalent up to $\alpha$-renaming, $f_i$ is a bijection and thereby an injection\footnote{In particular, it is not possible to rename two variables in $u'_i$ to the same one, since that would either materially change the result of $\{u'_i\} \circ W$ or, otherwise, imply that it was possible to merge the variables, contradicting the claim that $\{u'_i\} \circ W$ is in normal form.}. In the function \texttt{renamings} of Algorithm~\ref{alg.folding}, we see that all sets of injections are applied to $\{u'_1,\dots,u'_m\}$, including $\{f_1,\dots,f_m\}$. Therefore, $\{u_1,\dots,u_m\} \circ W$ will be constructed during the folding and, given our assumption that it is a decomposition, will be returned.
\end{proof}

\subsection{Remarks}

While the generation of folding of the $\Delta$-table is quite expensive\footnote{Experimental results show that the problem tends to become infeasible around term sets of size 50.}, the version shown here is naive and is amenable to significant optimizations. In particular, we only need to consider decompositions that are smaller than the term set they purport to compress, and can order the inspection of subsets of entries accordingly, starting with single-element ones and adding one $u_i$ at a time. In addition, various compromises can be made in terms of completeness while retaining soundness: generating all renamings via the function \texttt{renamings} can be foregone at surprisingly little cost to the quality of the results, and the generation of the $\Delta$-table can be cut off after a certain amount of time or number of entries created.\\

\section{Extensions}

For theoretical reasons, we might be interested in limiting the number of allowed $\alpha$ (bounded $\Delta_G$).

\subsection{Bounded generalized $\Delta$-Vector}

$\Delta_G$ will compute a unique decomposition that will preserve as much of the common structure of $t_1,\dots,t_n$ as possible, employing as many $\alpha$-instances as needed, but in some cases, it may be desirable to limit the number of such $\alpha$-instances that it may use.
Consider the following example:

$$
\begin{array}{l}
\Delta_G(f(g(a,b),g(c,d),e), f(g(x,y),g(u,v),w)) =\\
\\
\left(f(g(\alpha_1,\alpha_2),g(\alpha_3,\alpha_4),\alpha_5), \left(\colvec{a\\b\\c\\d\\e}, \colvec{x\\y\\u\\v\\w}\right)\right)
\end{array}
$$

This illustrates two points:
\begin{enumerate}
\item There is a non-deterministic choice: we could restrict the number of $\alpha$-instances to, say, 4. This can be achieved by right-shifting $\alpha_1$ and $\alpha_2$ into a new $\alpha'$ (with the terms $(g(a,b),g(x,y))$) or $\alpha_3$ \& $\alpha_4$ (with the terms $(g(c,d),g(u,v))$).
\item Generally, we cannot say that, for any $k$, decompositions with exactly $k$ variables exist. For example, if we restrict the number of $\alpha$-instances to at most 2 in $u$, we only get the trivial decomposition $(\alpha, (f(g(a,b),g(c,d),e), f(g(x,y),g(u,v),w)))$.
\end{enumerate}

We can see that we can specify upper, but not lower bounds on the number of variables which may be used, although this burdens us with a non-deterministic choice as to for which $\alpha$-instances to right-shift.\\

\subsubsection{Calculating the set of all decompositions with at most $k$ variables}

$\Delta_G$ can be slightly altered to compute decompositions with at most $k$ variables. We do this by introducing a parameter $k$ and a non-deterministic boolean variable \textbf{RANDOM}, creating $\Delta_G^k$:

$$
  \Delta_G^k(t_1,\dots,t_n) = \left\{
    \begin{array}{l}

    (t_1,()) \mt{ if } t_1 = t_2 = \dots = t_n \mt{ and } n > 0\\
    \\

    \texttt{nub}(f(u_1,\dots,u_m), (\bar{s_1},\dots,\bar{s_q}))
    \\
    \quad
    \begin{array}{l l}
      \mt{if all } & t_i = f(t_1^i,\dots,t_m^i) \mt{, case 1 does not apply, and}\\
      & ((\textbf{RANDOM} \mt{ = true and } |\{\bar{s_1},\dots,\bar{s_q}\}| \leq k) \mt{ or}\\
      & \ m = 1)\\
      \\
      \mt{where } & (\bar{s_1},\dots,\bar{s_q}) = \bigsqcup\limits_{1 \leq j \leq m} \pi_2(\Delta_G^k(t_j^1,\dots,t_j^n)) \mt{ and}\\
                  & u_j = \pi_1(\Delta_G^k(t_j^1,\dots,t_j^n)) \mt{ for all } j \in \{1,\dots,m \}\\
    \end{array}
    
    \\
    \\
    
    (\alpha_{\mt{UNIQUE}},(t_1,\dots,t_n))\quad \mt{otherwise}\\
    \end{array}
  \right.
$$

\begin{algorithm}
\caption{Bounded Generalized $\Delta$-vector \DeltaGk}
\label{alg.DeltaGk}
\begin{algorithmic}
\Function{\DeltaGk}{$t_1,\ldots,t_n$: a list of terms}
  \State \Return transposeW(\DeltaGk'($t_1,\ldots,t_n$))
\EndFunction
\Function{\DeltaGk'}{$t_1,\ldots,t_n$: a list of terms}
  \If{$t_1 = t_2 = \ldots = t_n \land n > 0$}
    \Comment case 1: all terms identical
    \State \Return $(t_1,())$
  \ElsIf{\texttt{GUARD} $\land t_i = f(t_1^i,\ldots,t_m^i)$ for $1\leq i\leq n$}
    \Comment case 2: recurse
    \State $(\bar{w}_1,\dots,\bar{w}_q) \gets \bigsqcup\limits_{1 \leq j \leq m} \pi_2(\Delta_G(t_j^1,\ldots,t_j^n))$
    \Comment $\bigsqcup \equiv$ concatenation
    \State $u_j \gets \pi_1(\Delta_G(t_j^1,\ldots,t_j^n))$ for all $j \in \{1,\ldots,m \}$
    \State \Return nub($f(u_1,\ldots,u_m), (\bar{w}_1,\ldots,\bar{w}_q)$)
  \Else
    \Comment case 3: introduce new $\alpha$
    \State \Return $(\alpha_\mt{FRESH}, (t_1,\ldots,t_n))$
  \EndIf
\EndFunction
\State
\State where \texttt{GUARD} is $m = 1 \lor (\textbf{RANDOM} = \texttt{true} \land \{\bar{w}_1,\dots,\bar{w}_q\} \leq k)$.
\end{algorithmic}
\end{algorithm}

The side-condition for the instantation of $\alpha_{\mt{FRESH}}$ is the same as in $\Delta_G$: the leftmost occurrence is $\alpha_1$ and all instances are numbered incrementally left-to-right.\\

The second case of $\Delta_G^k$ now has an additional condition: first, either the function symbol $f$ at the head of $t_1,\dots,t_n$ is unary, or the non-deterministic variable \textbf{RANDOM} is true and, after the application of \texttt{nub}, there are at most $k$ $w$-vectors. If we have a unary function symbol, we can always choose the second case because doing so does not immediately necessitate more than one variable. If the function symbol is not unary, we non-deterministically recurse, as long as the resulting decomposition does not contain more than $k$ variables. This accounts for the non-deterministic nature of right-shifting: randomly terminating our search for a common term structure early is equivalent to first computing $\Delta_G$ and then non-deterministically right-shifting to reduce the number of variables.\\

It is easy to see that decompositions computed by $\Delta_G^k$ need not be in normal form. A simple example is the following:
$$
  \Delta_G^\infty(f(a),f(b)) = \{(\alpha_1,( f(a), f(b) )), (f(\alpha_1), (a, b) )\}
$$

Due to its non-determinism, $\Delta_G^\infty$ computed the trivial decomposition, even though a left-shift is possible on it. To talk about the result of $\Delta_G^k$, we therefore need the notion of a weaker normal form:

\begin{definition}
\textbf{Weak k-normal form.}
A decomposition $U \circ W$ is in weak k-normal form if $\leq k$ variables occur in $U$, merging and $\alpha$-elimination are not possible, and any left-shifting would result in $> k$ variables in $U$.
\end{definition}

\noindent
Thus equipped, we can give the following correctness result:

%SOUNDNESS:
%The algorithm is techincally, but not naturally sound!
%Randomly jumping into the otherwise-case is premature. Even if we would temporarily get too many
%variables, we still might be able to merge them back! All the results of Delta_G^k are in some weak NF, but
%the notion of weak NFs itself is flawed because of the the possibility of first left-shifting and then merging.

%I don't think this can be easily fixed; calculating Delta_G and right-shifting might prove more fruitful, both in theory and practice.

\begin{theorem}
\textbf{Soundness of $\Delta_G^k$.}
Let $t_1,\dots,t_n$ be terms and let $k\geq 1$.\\
If $(u,W) \in \Delta_G^k(t_1,\dots,t_n)$, then $\{u\} \circ W$ is in weak $l$-normal form (for some $l \in \{1,\dots,k\}$) and $t_i = u[\bar{\alpha}\backslash\bar{w}_i]$ ($1\leq i \leq n)$.
\label{thm:DeltaGkSoundness}
\end{theorem}

\begin{proof}
The proof is largely analogous to that given in Theorem~\ref{thm:DeltaGSoundness}. Since $\Delta_G^k$ only differs from $\Delta_G$ in that it non-deterministically chooses its ``otherwise''-case, we need only show two additional claims:

\begin{enumerate}
  \item choosing the third case where $\Delta_G$ would choose its second case still results in a decomposition and
  \item $\{u\} \circ W$ is in weak $l$-normal form for some $1 \leq l \leq k$.
\end{enumerate}

The first claim is clearly true.\\

For the second claim, note that the condition $|\{\bar{w}_1,\dots,\bar{w}_q\}| \leq k$ in the second case of $\Delta_G^k$ forces the third case to be chosen whenever more than $k$ distinct variables occur in some subtree of $u$, including $u$ itself. Therefore, $\Delta_G^k$ will never return a decomposition with more than $k$ variables. Now let $l$ be the number of variables occurring in $u$; we see that we also cannot perform a left-shift without increasing the number of variables in $u$, as is evident by examining the $W$. For any $i$, we distinguish three cases for the form of $w = (w_{i,1},\dots,w_{i,n})$:
\begin{enumerate}
  \item $w = (c_1,\dots,c_n)$ where not all $c_i$ have a common function symbol of the same arity. In this case, no left-shift is possible at all.
  \item $w = (f(a_1),\dots,f(a_n))$. Such vector would permit a left-shift without increasing the number of variables. However, such an $w$ cannot exist because it would imply that $\Delta_G^k(f(a_1),\dots,f(a_n))$ chose its third case. The condition $m = 1$ in the second case of $\Delta_G^k$ precludes that.
  \item $w = (f(a_1^1,\dots,a_1^r),\dots,f(a_n^1,\dots,a_n^r))\ (r > 1)$. If we were to left-shift for the corresponding variable, we would increase the number of variables by $r-1$, resulting in at least $l+1$ variables. Consequently, $\{u\} \circ W$ would no longer be in weak $l$-normal form.
\end{enumerate}
\end{proof}

%-------------------------------------------------------------------------------------------------

\begin{theorem}
\textbf{Completeness of $\Delta_G^k$.}
If we evaluate for all possible assignments for \textbf{RANDOM}, $\Delta_G^k$ returns the set of all decompositions which are in weak $l$-normal form (for some $l \in \{1,\dots,k\}$).
\label{thm:DeltaGkCompletenss}
\end{theorem}

\begin{proof}
Let $l \in \{1,\dots,k\}$ and let $\{u\} \circ W$ be a decomposition in weak $l$-normal form.\\

We first note that the condition $|\{\bar{w}_1,\dots,\bar{w}_q\}| \leq k$ is {\em necessary} for weak $l$-normal forms: if there are more than $k$ distinct variables (evidenced by the distinct $w$-vectors), these cannot be merged with each other, and the decomposition cannot be in weak $l$-normal form ($1 \leq l \leq k$).\\

Now we proceed by induction on the maximal depth of $t_1,\dots,t_n$. The proof is entirely analogous to that for Theorem~\ref{thm:DeltaGCompleteness}, except for point 2 of the step case, which will be given here.\\

\noindent
The induction hypothesis is that $\Delta_G^k$ is complete for depth $\leq d$. In point 2 of the step case, assuming that not all terms are equal, we distinguish two sub-cases:
  \begin{enumerate}
    \item $t_1,\dots,t_n $ start with a common unary function symbol, i.e. $m = 1$ and $t_1,\dots,t_n = f(t_1^1,\dots,t_n^1)$. Then, $u$ can only be of the form $u=f(u_1)$, since it wouldn't be in weak $l$-normal form otherwise.
    This corresponds to the second case of $\Delta_G^k$, since $m = 1$ is true. Per the IH, $\Delta_G^k$ is complete for $t_1^1,\dots,t_1^n$.
    \item $t_1,\dots,t_n$ start with a common function symbol of arity $m > 1$. $u$ may either be of the form $u=\alpha$ or $u=f(u_1,\dots,u_m)$. The first form corresponds to the third case. The second form corresponds to the second case of $\Delta_G^k$ and the IH applies in the same manner as it applied in the step case of $\Delta_G$'s completeness proof. Due to \textbf{RANDOM} being non-deterministic, both forms are chosen and hence $\Delta_G^k$ is complete.
  \end{enumerate}
\end{proof}

\medskip

Unlike the normal form, weak k-normal forms are not unique, as the following example shows:

$$
  \begin{array}{l}
    \Delta_G^\infty(f(g(a,b),g(c,d),e), f(g(x,y),g(u,v),w)) =\\
    \\
    \left\{\left(f(\alpha_1,\alpha_2,\alpha_3), \left(\colvec{g(a,b)\\g(c,d)\\e}, \colvec{g(x,y)\\g(u,v)\\w}\right)\right), \dots\right\}
  \end{array}
$$

As we can see, this is the same termset as in the previous example, but here, we have terminated the search early in the case of $\alpha_1$ and $\alpha_2$. The decomposition shown has 3 variables. If we want to get to weak 4-normal form, we can left-shift either for $\alpha_1$ and $\alpha_2$, but not for both. Therefore, we can create two different weak normal forms.\\

Another property is that one weak k-normal form might reduce to another weak k-normal form, without the intermediate decompositions being in weak k-normal form themselves. This simple example illustrates:

$$
  \begin{array}{l}
    \left(f(\alpha_1,\alpha_3), \left(\colvec{g(a,c)\\a}, \colvec{g(b,d)\\b}\right)\right)\\
    \left(f(g(\alpha_1,\alpha_2),\alpha_1), \left(\colvec{a\\c}, \colvec{b\\d}\right)\right)
  \end{array}
$$
\noindent
Both decompositions are in weak 2-normal form. However, by left-shifting for $\alpha_1$ in the first one, we get

$$
  \left(f(g(\alpha_1,\alpha_2),\alpha_3), \left(\colvec{a\\c\\a}, \colvec{b\\d\\b}\right)\right)
$$
\noindent
and, after merging $\alpha_1$ and $\alpha_3$:

$$
 \left(f(g(\alpha_1,\alpha_2),\alpha_1), \left(\colvec{a\\c}, \colvec{b\\d}\right)\right)
$$
\noindent
The intermediate $\left(f(g(\alpha_1,\alpha_2),\alpha_3), \left(\colvec{a\\c\\a}, \colvec{b\\d\\b}\right)\right)$, however, is not in weak 2-normal form.\\

The definition of weak normal forms could be altered to forbid the possibility of such reductions instead of simply the possibility of left-shifts, but a conscious choice was made against it: decompositions such as the two in this example, though related, are materially different, and, for the purpose of finding ``intuitive'' cut-formulas, it might be advantageous to consider both.

\bibliographystyle{plain}
\bibliography{references}
\end{document}